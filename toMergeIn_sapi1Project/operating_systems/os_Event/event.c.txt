/* Copyright 2016, Pablo Ridolfi.
 * Copyright 2016, Eric Pernia.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 *    contributors may be used to endorse or promote products derived from this
 *    software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/* Date: 2016-10-06 */

/*==================[inclusions]=============================================*/

#include "os.h"
#include "os_config.h"
#include "board.h"

/*==================[macros and definitions]=================================*/

/*==================[internal data declaration]==============================*/

/*==================[internal functions declaration]=========================*/

/*==================[internal data definition]===============================*/


static os_event_control_block_t eventBuffer[ EVENT_COUNT ]; // Creo un vector (privado) de la cantidad de eventos que me configuraron en os_config.h
static os_event_t eventsUsed = 0; // Variable (privada) que indica la cantidad de eventos ya creados

/*==================[external data definition]===============================*/

extern taskControlBlock task_control_list[TASK_COUNT];

/*==================[internal functions definition]==========================*/

/*==================[external functions definition]==========================*/

os_event_t os_event_init(void)
{
	os_event_t ev;

	if( eventsUsed < EVENT_COUNT ){

		ev = eventsUsed;

		eventBuffer[eventsUsed].counter = 0;
		circularBufferConfig(
			&(eventBuffer[eventsUsed].eventTasksCircularBuff),
			eventBuffer[eventsUsed].eventTasksCircularBuffMemory,
			EVENT_TASK_BUFFER_SIZE, 0, 0
		);

		eventsUsed++;

	} else{
		ev = INVALID_EVENT;
	}

	/* TODO: implemente esta función y devuelva el ID del evento creado */
	return ev;
}

int32_t os_event_wait( os_event_t ev ) // Bloquea la tarea a la espera del evento
{
	int32_t rv;

	uint32_t runningTask;

	if( ev == INVALID_EVENT ){
		rv = -1;
	} else {

		// Si el contador es positivo lo decremento
		if( (eventBuffer[ev].counter) > 0	){
			(eventBuffer[ev].counter)--;
		}
		// si el contador es igual o menor a 0
		else{

			// Obtengo la tarea que está usando la CPU.
			runningTask = os_get_running_task();

			// Pongo al tarea en estado Waiting
			task_control_list[runningTask].state = TASK_STATE_WAITING;

			// guardo la tarea en el buffer de tareas a la espera del evento
			circularBufferWrite(
				&(eventBuffer[ev].eventTasksCircularBuff),
				&runningTask
			);

			// Llamo al scheduler
			schedule();

		}

		rv = 0;
	}

	/* TODO: implemente esta función y devuelva 0 (OK) */
	return rv;
}

int32_t os_event_set(os_event_t ev) // Activa el evento a una tarea desbloqueandola
{
	int32_t rv;

	uint32_t waitingTask;

	if( ev == INVALID_EVENT ){
		rv = -1;
	} else {

		// Si la cola de tareas esperando el evento esta vacia, incremento el contador
		if( (eventBuffer[ev].eventTasksCircularBuff).status == CIRCULAR_BUFFER_EMPTY ){
			(eventBuffer[ev].counter)++;
		}
		// Si hay alguna tarea esperando el evento
		else{

			// Saco la tarea del buffer de tareas esperando por el evento
			// y la guardo en waitingTask
			circularBufferRead(
				&(eventBuffer[ev].eventTasksCircularBuff),
				&waitingTask
			);

			// Pongo la tarea waitingTask en ready
			task_control_list[waitingTask].state = TASK_STATE_READY;

			// Añado waitingTask a la lista de tareas ready
			add_ready( task_list[waitingTask].prio, waitingTask );

			// Llamo al scheduler
			schedule();

		}

		rv = 0;
	}

	/* TODO: implemente esta función y devuelva 0 (OK) */
	return rv;
}


/*

os_event_t os_event_init(void)
{
	os_event_t ev = INVALID_EVENT;
	// implemente esta función y devuelva el ID del evento creado
	return ev;
}

int32_t os_event_wait(os_event_t ev)
{
	int32_t rv = -1;
	// implemente esta función y devuelva 0 (OK)
	return -1;
}

int32_t os_event_set(os_event_t ev)
{
	int32_t rv = -1;
	// implemente esta función y devuelva 0 (OK)
	return -1;
}

*/

/*==================[end of file]============================================*/
