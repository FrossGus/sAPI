->
.
char*

.indexOf
.substring
.toInt
.length

m_puart->available
m_puart->read
m_puart->write


char*
esp8266_RecvFind
esp8266_RecvString

--------------------------------------------------

// Concateno magString+","+axisAsString
strncat( magString, axisAsString, strlen(axisAsString) );

bool_t int64ToString( int64_t value, char* result, uint8_t base )

--------------------------------------------------


.indexOf() - https://www.arduino.cc/en/Reference/StringIndexOf
reemplazar por:

   char * strstr (const char * s1, const char * s2); / * C sólo * /

   char *str1 = "Borland International", *str2 = "nation", *ptr;
   ptr = strstr(str1, str2);
   
.substring() - https://www.arduino.cc/en/Reference/StringSubstring
reemplazar por:
   
   https://www.tutorialspoint.com/c_standard_library/string_h.htm
   https://stackoverflow.com/questions/10530064/how-to-use-substring-function-in-c

.toInt() - https://www.arduino.cc/en/Reference/StringObject
reemplazar por:

   int atoi(const char *str)

.length() - https://www.arduino.cc/en/Reference/StringLength
reemplazar por:

   strlen(rtcString)
 
--------------------------------------------------

esp8266_GetVersion
   esp8266_ATGMR_Expect
      esp8266_RecvFindAndFilter
      
      
esp8266_ATCIPSEND_SendSingle


254 esp8266_ATCIPSERVER_Send



esp8266_RecvFindAndFilter
esp8266_RecvFindAndFilterTimeout

--------------------------------------------------

PARAMETROS POR DEFECTO, VAN EN EL PROTOTIPO:

typedef enum{
   SOFT_AP_CHANNEL_1       = 1,
   SOFT_AP_CHANNEL_2       = 2,
   SOFT_AP_CHANNEL_3       = 3,
   SOFT_AP_CHANNEL_4       = 4,
   SOFT_AP_CHANNEL_5       = 5,
   SOFT_AP_CHANNEL_6       = 6,
   SOFT_AP_CHANNEL_7       = 7,
   SOFT_AP_CHANNEL_8       = 8,
   SOFT_AP_CHANNEL_9       = 9,
   SOFT_AP_CHANNEL_10      = 10,
   SOFT_AP_CHANNEL_11      = 11,
   SOFT_AP_CHANNEL_12      = 12,
   SOFT_AP_CHANNEL_13      = 13,
   SOFT_AP_CHANNEL_DEFAULT = SOFT_AP_CHANNEL_7
} softAP_channel_t;

typedef enum{
   SOFT_AP_ENCRYPSTION_OPEN         = 0,
   SOFT_AP_ENCRYPSTION_WEP          = 1,
   SOFT_AP_ENCRYPSTION_WPA_PSK      = 2,
   SOFT_AP_ENCRYPSTION_WPA2_PSK     = 3,
   SOFT_AP_ENCRYPSTION_WPA_WPA2_PSK = 4,
   SOFT_AP_ENCRYPSTION_DEFAULT      = SOFT_AP_ENCRYPSTION_WPA_WPA2_PSK
} softAP_channel_t;

/*
 * @param chl - the channel (1 - 13, default: 7). 
 * @param ecn - the way of encrypstion (0 - OPEN, 1 - WEP, 2 - WPA_PSK, 3 - WPA2_PSK, 4 - WPA_WPA2_PSK, default: 4). 
 */
bool setSoftAPParam(String ssid, String pwd, uint8_t chl = 7, uint8_t ecn = 4);

/* @param timeout - the duration for timeout by second(0 ~ 28800, default:180). */
bool setTCPServerTimeout(uint32_t timeout = 180);

/* @param port - the port number to listen(default: 333). */
bool startTCPServer(uint32_t port = 333);
bool startServer(uint32_t port = 333);

/* @param timeout - the time waiting data. */
uint32_t recv(uint8_t *buffer, uint32_t buffer_size, uint32_t timeout = 1000);    
uint32_t recv(uint8_t mux_id, uint8_t *buffer, uint32_t buffer_size, uint32_t timeout = 1000);    
uint32_t recv(uint8_t *coming_mux_id, uint8_t *buffer, uint32_t buffer_size, uint32_t timeout = 1000);    
String recvString(String target, uint32_t timeout = 1000);
String recvString(String target1, String target2, uint32_t timeout = 1000);
String recvString(String target1, String target2, String target3, uint32_t timeout = 1000);
bool recvFind(String target, uint32_t timeout = 1000);
bool recvFindAndFilter(String target, String begin, String end, String &data, uint32_t timeout = 1000);

/* @param port - the port number to listen(default: 333). */
bool sATCIPSERVER(uint8_t mode, uint32_t port = 333);


-------------------------------------------------------------
   
typedef enum{
   // Working states
   UART_RECEIVE_STRING_INIT,
   UART_RECEIVE_STRING_RECEIVING,
   // Ok state
   UART_RECEIVE_STRING_RECEIVED_OK,
   UART_RECEIVE_STRING_RECEIVED_OK_ALL,
   // Error states
   UART_RECEIVE_STRING_ERROR, // Por ahora todos los Errores dan este como que este mal el tamaño de un vector
   UART_RECEIVE_STRING_TIMEOUT
} waitForReceiveStringsOrTimeoutState_t;

typedef enum{
   UART_RECEIVE_STRING_FIRST,  // Receive until first match
   UART_RECEIVE_STRING_ALL     // Continue receiving until receive all strings
} waitForReceiveStringsOrTimeoutMode_t;

typedef struct{
   char*           str;
   uint16_t        strLen;
   int32_t         receiveStrStartIndex; // -1 not receive, 0 or more if receive
   uint16_t        index;
   bool_t          complete;
} expectString_t;

typedef struct{
   waitForReceiveStringsOrTimeoutState_t state;
   waitForReceiveStringsOrTimeoutMode_t  mode;
   expectString_t* strList;
   uint16_t        strListSize;
   char*           receiveStr;
   uint32_t        receiveStrLen;
   uint32_t        receiveStrMaxLen;
   tick_t          timeout;
   delay_t         delay;
} waitForReceiveStringsOrTimeout_t;
} waitForReceiveStringsOrTimeout_t;

-------------------------------------------------------------------------------

instance->state;
instance->mode;

(instance->strList[i])->str[i];
(instance->strList[i])->strLen;
(instance->strList[i])->receiveStrStartIndex;
(instance->strList[i])->index;
(instance->strList[i])->complete;

instance->strListSize;

instance->receiveStr[i];
instance->receiveStrMaxLen;
instance->receiveStrLen;
instance->timeout;
instance->delay;

-------------------------------------------------------------------------------
"saraza pepha pepe hola marola pirola chau"
   
Si recibo un byte y la cantidad de recibidos es menor al maximo permitido
   FOR each in List
      Si complete != TRUE
         Si acierta y encuentra el primer caracter (index = 0), setea receiveStrStartIndex con (receiveStrLen = -1)
         Si acierta incrementa index (index++), luego de incrementar el index: 
            Si index == strLen
               complete = TRUE
               si está en modo UART_RECEIVE_STRING_FIRST 
                  return TRUE
         Si falla resetea index (index = 0) y resetea receiveStrStartIndex (receiveStrStartIndex = -1)

-------------------------------------------------------------------------------
   
receiveStr = "" {receiveStrLen = 0} {receiveStrMaxLen = 49}
   
strList[0] {str = "mar"} {index = 0} {strLen = 4} {receiveStrStartIndex = -1} {complete = FALSE}
strList[1] {str = "pepe"} {index = 0} {strLen = 4} {receiveStrStartIndex = -1} {complete = FALSE}
strList[2] {str = "hola marola"} {index = 0} {strLen = 11} {receiveStrStartIndex = -1} {complete = FALSE}
strList[3] {str = "chau"} {index = 0} {strLen = 4} {receiveStrStartIndex = -1} {complete = FALSE}

Si un string esta en true entronces no lo chequeo

-------------------------------------------------------------------------------
   
====== 7 iteraciones ======
   
receiveStr = "saraza " {receiveStrLen = 7} {receiveStrMaxLen = 49}   
   
strList[0] {str = "mar"} {index = 0} {strLen = 4} {receiveStrStartIndex = -1}
strList[1] {str = "pepe"} {index = 0} {strLen = 4} {receiveStrStartIndex = -1}
strList[2] {str = "hola marola"} {index = 0} {strLen = 11} {receiveStrStartIndex = -1}
strList[3] {str = "chau"} {index = 0} {strLen = 4} {receiveStrStartIndex = -1}

-------------------------------------------------------------------------------
   
====== 8 ======

receiveStr = "saraza p" {receiveStrLen = 8} {receiveStrMaxLen = 49}
   
strList[0] {str = "mar"} {index = 0} {strLen = 4} {receiveStrStartIndex = -1}
strList[1] {str = "pepe"} {index = 1} {strLen = 4} {receiveStrStartIndex = 7 = (receiveStrLen-1)}
strList[2] {str = "hola marola"} {index = 0} {strLen = 11} {receiveStrStartIndex = -1}
strList[3] {str = "chau"} {index = 0} {strLen = 4} {receiveStrStartIndex = -1}

-------------------------------------------------------------------------------
   
====== 9 ======

receiveStr = "saraza pe" {receiveStrLen = 9} {receiveStrMaxLen = 49}
   
strList[0] {str = "mar"} {index = 0} {strLen = 4} {receiveStrStartIndex = -1}
strList[1] {str = "pepe"} {index = 2} {strLen = 4} {receiveStrStartIndex = 7}
strList[2] {str = "hola marola"} {index = 0} {strLen = 11} {receiveStrStartIndex = -1}
strList[3] {str = "chau"} {index = 0} {strLen = 4} {receiveStrStartIndex = -1}

-------------------------------------------------------------------------------
   
====== 10 ======

receiveStr = "saraza pep" {receiveStrLen = 10} {receiveStrMaxLen = 49}
   
strList[0] {str = "mar"} {index = 0} {strLen = 4} {receiveStrStartIndex = -1}
strList[1] {str = "pepe"} {index = 3} {strLen = 4} {receiveStrStartIndex = 7}
strList[2] {str = "hola marola"} {index = 0} {strLen = 11} {receiveStrStartIndex = -1}
strList[3] {str = "chau"} {index = 0} {strLen = 4} {receiveStrStartIndex = -1}

-------------------------------------------------------------------------------
   
====== 11 ======

receiveStr = "saraza peph" {receiveStrLen = 11} {receiveStrMaxLen = 49}
   
strList[0] {str = "mar"} {index = 0} {strLen = 4} {receiveStrStartIndex = -1} {complete = FALSE}
strList[1] {str = "pepe"} {index = 0} {strLen = 4} {receiveStrStartIndex = -1} {complete = FALSE}
strList[2] {str = "hola marola"} {index = 1} {strLen = 11} {receiveStrStartIndex = 10 = (receiveStrLen-1)} {complete = FALSE}
strList[3] {str = "chau"} {index = 0} {strLen = 4} {receiveStrStartIndex = -1} {complete = FALSE}

-------------------------------------------------------------------------------
   
====== 12 ======

receiveStr = "saraza pepha" {receiveStrLen = 12} {receiveStrMaxLen = 49}
   
strList[0] {str = "mar"} {index = 0} {strLen = 4} {receiveStrStartIndex = -1} {complete = FALSE}
strList[1] {str = "pepe"} {index = 0} {strLen = 4} {receiveStrStartIndex = -1} {complete = FALSE}
strList[2] {str = "hola marola"} {index = 0} {strLen = 11} {receiveStrStartIndex = -1} {complete = FALSE}
strList[3] {str = "chau"} {index = 0} {strLen = 4} {receiveStrStartIndex = -1} {complete = FALSE}

-------------------------------------------------------------------------------
   
====== 13 ======

receiveStr = "saraza pepha " {receiveStrLen = 13} {receiveStrMaxLen = 49}
   
strList[0] {str = "mar"} {index = 0} {strLen = 4} {receiveStrStartIndex = -1} {complete = FALSE}
strList[1] {str = "pepe"} {index = 0} {strLen = 4} {receiveStrStartIndex = -1} {complete = FALSE}
strList[2] {str = "hola marola"} {index = 0} {strLen = 11} {receiveStrStartIndex = -1} {complete = FALSE}
strList[3] {str = "chau"} {index = 0} {strLen = 4} {receiveStrStartIndex = -1} {complete = FALSE}

-------------------------------------------------------------------------------
   
====== 14 ======

receiveStr = "saraza pepha p" {receiveStrLen = 14} {receiveStrMaxLen = 49}
   
strList[0] {str = "mar"} {index = 0} {strLen = 4} {receiveStrStartIndex = -1} {complete = FALSE}
strList[1] {str = "pepe"} {index = 1} {strLen = 4} {receiveStrStartIndex = 13} {complete = FALSE}
strList[2] {str = "hola marola"} {index = 0} {strLen = 11} {receiveStrStartIndex = -1} {complete = FALSE}
strList[3] {str = "chau"} {index = 0} {strLen = 4} {receiveStrStartIndex = -1} {complete = FALSE}

-------------------------------------------------------------------------------
   
====== 15 ======

receiveStr = "saraza pepha pe" {receiveStrLen = 15} {receiveStrMaxLen = 49}
   
strList[0] {str = "mar"} {index = 0} {strLen = 4} {receiveStrStartIndex = -1} {complete = FALSE}
strList[1] {str = "pepe"} {index = 2} {strLen = 4} {receiveStrStartIndex = 13} {complete = FALSE}
strList[2] {str = "hola marola"} {index = 0} {strLen = 11} {receiveStrStartIndex = -1} {complete = FALSE}
strList[3] {str = "chau"} {index = 0} {strLen = 4} {receiveStrStartIndex = -1} {complete = FALSE}

-------------------------------------------------------------------------------
   
...
   
-------------------------------------------------------------------------------
   
====== 17 ======

receiveStr = "saraza pepha pepe" {receiveStrLen = 17} {receiveStrMaxLen = 49}
   
strList[0] {str = "mar"} {index = 0} {strLen = 4} {receiveStrStartIndex = -1} {complete = FALSE}
strList[1] {str = "pepe"} {index = 2} {strLen = 4} {receiveStrStartIndex = 13} {complete = TRUE}
strList[2] {str = "hola marola"} {index = 0} {strLen = 11} {receiveStrStartIndex = -1} {complete = FALSE}
strList[3] {str = "chau"} {index = 0} {strLen = 4} {receiveStrStartIndex = -1} {complete = FALSE}

-------------------------------------------------------------------------------
   
====== 18 ... 23 ======

receiveStr = "saraza pepha pepe hola " {receiveStrLen = 23} {receiveStrMaxLen = 49}
   
strList[0] {str = "mar"} {index = 0} {strLen = 4} {receiveStrStartIndex = -1} {complete = FALSE}
strList[1] {str = "pepe"} {index = 3} {strLen = 4} {receiveStrStartIndex = 13} {complete = TRUE}
strList[2] {str = "hola marola"} {index = 4} {strLen = 11} {receiveStrStartIndex =18} {complete = FALSE}
strList[3] {str = "chau"} {index = 0} {strLen = 4} {receiveStrStartIndex = -1} {complete = FALSE}

-------------------------------------------------------------------------------
   
......................

-------------------------------------------------------------------------------
   
====== 41 ======

receiveStr = "saraza pepha pepe hola marola pirola chau"{receiveStrLen = 41} {receiveStrMaxLen = 49}
   
strList[0] {str = "mar"} {index = 2} {strLen = 4} {receiveStrStartIndex = 23} {complete = TRUE}
strList[1] {str = "pepe"} {index = 3} {strLen = 4} {receiveStrStartIndex = 13} {complete = TRUE}
strList[2] {str = "hola marola"} {index = 10} {strLen = 11} {receiveStrStartIndex =18} {complete = TRUE}
strList[3] {str = "chau"} {index = 3} {strLen = 4} {receiveStrStartIndex = 37} {complete = TRUE}

-------------------------------------------------------------------------------
"saraza pepha pepe hola marola pirola chau"
-------------------------------------------------------------------------------


   
   
   
                                                                                                                                                                                                                                                                    
   
   
   
   
   
                                                                                                                     
   
/* Copyright 2017, Eric Pernia.
 * All rights reserved.
 *                                                                         
 * This file is part sAPI library for microcontrollers.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 *    contributors may be used to endorse or promote products derived from this
 *    software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */

/*
 * Date: 2016-04-26
 */

/* Diagrama de conexion ESP8266

   VCC ESP8266 <--> +3.3V EDU-CIAA-NXP
   RST ESP8266 <--> (SIN CONEXION)
 CH_PD ESP8266 <--> +3.3V EDU-CIAA-NXP
    TX ESP8266 <--> RX EDU-CIAA-NXP

    RX ESP8266 <--> TX EDU-CIAA-NXP
 GPIO0 ESP8266 <--> (SIN CONEXION)
 GPIO0 ESP8266 <--> (SIN CONEXION)
   GND ESP8266 <--> GND EDU-CIAA-NXP

  AT commands: http://www.pridopia.co.uk/pi-doc/ESP8266ATCommandsSet.pdf
*/

/*==================[inclusions]=============================================*/

#include "sapi.h"                 /* <= sAPI header */

#include <string.h>   // <= Biblioteca de manejo de Strings, ver:
// https://es.wikipedia.org/wiki/String.h
// http://www.alciro.org/alciro/Programacion-cpp-Builder_12/funciones-cadenas-caracteres-string.h_448.htm

/*==================[macros and definitions]=================================*/

#define BAUD_RATE 115200 // Baudrate por defecto del ESP8266

/*==================[internal data declaration]==============================*/

/*==================[internal functions declaration]=========================*/

/*==================[internal data definition]===============================*/

DEBUG_PRINT_ENABLE

/*==================[external data definition]===============================*/

/*==================[internal functions definition]==========================*/

/*==================[external functions definition]==========================*/

void imprimirMensajeDeBienvenida( void ){

   /* Imprimo el mensaje de bienvenida */
   uartWriteString( UART_USB, 
      "Bievenido al asistente de configuracion del modulo ESP8266\r\n" );
   uartWriteString( UART_USB, 
      "Antes de continuar, por favor asegurese que su terminal\r\n" );
   uartWriteString( UART_USB, 
      "serie dispone del terminador CR+LF (enter)\r\n\r\n" );
   uartWriteString( UART_USB, 
      "A continuacion se realiza un listado de algunos de los\r\n" );
   uartWriteString( UART_USB, "comandos AT disponibles:\r\n\r\n" );
   uartWriteString( UART_USB, 
      "> Saber si el modulo responde correctamente: AT\r\n" );
   uartWriteString( UART_USB, 
      "> Version del Firmware: AT+GMR\r\n" );
   uartWriteString( UART_USB, "> Resetear el modulo: AT+RST\r\n" );
   uartWriteString( UART_USB, 
      "> Listar todas las redes disponibles: AT+CWLAP\r\n" );
   uartWriteString( UART_USB, 
      "> Checkear la red actual: AT+CWJAP?\r\n" );
   uartWriteString( UART_USB, 
      "> Unirse a una red: AT+CWJAP=\"nombreRedInalambrica\",\"password\"\r\n" );
   uartWriteString( UART_USB, 
      "  - NOTA: Las comillas dobles son parte del mensaje\r\n" );
   uartWriteString( UART_USB, 
      "> Salir de la red: AT+CWQAP\r\n" );

   delay(100);
}


/* FUNCION PRINCIPAL, PUNTO DE ENTRADA AL PROGRAMA LUEGO DE RESET. */
int main(void){

   /* ------------- INICIALIZACIONES ------------- */

   /* Inicializar la placa */
   boardConfig();

   /* Inicializar las UART a 115200 baudios */
   uartConfig( UART_USB, BAUD_RATE );
   uartConfig( UART_232, BAUD_RATE );
   
   
   
   
   // PRUEBA: "saraza pepe pope hola marola pirola chau"

   expectString_t expectStringList[4] = {
      { .str = "mar", .strLen = 3 },
      { .str = "pepe", .strLen = 4 },
      { .str = "hola marola", .strLen = 11 },
      { .str = "chau", .strLen = 4 }
   };
   char receivedStringResult[50];

   waitForReceiveStringsOrTimeout_t waitStrList = {
      .state = UART_RECEIVE_STRING_INIT,
      .mode = UART_RECEIVE_STRING_FIRST, // UART_RECEIVE_STRING_FIRST or UART_RECEIVE_STRING_ALL
      .strList = expectStringList,
      .strListSize = 4,
      .receiveStr = receivedStringResult,
      .receiveStrMaxLen = 55,
      .timeout = 10000
   };
   waitForReceiveStringsOrTimeoutState_t waitStrListResultState;

   while( waitStrListResultState != UART_RECEIVE_STRING_RECEIVED_OK     &&
          waitStrListResultState != UART_RECEIVE_STRING_RECEIVED_OK_ALL &&
          waitStrListResultState != UART_RECEIVE_STRING_ERROR           &&
          waitStrListResultState != UART_RECEIVE_STRING_TIMEOUT )
   {
      waitStrListResultState = waitForReceiveStringsOrTimeout( UART_USB, &waitStrList );
   }

   // Print result
   if( (waitStrListResultState == UART_RECEIVE_STRING_RECEIVED_OK) ){
      debugPrintlnString( "UART_RECEIVE_STRING_RECEIVED_OK" );
   }
   if( (waitStrListResultState == UART_RECEIVE_STRING_RECEIVED_OK_ALL) ){
      debugPrintlnString( "UART_RECEIVE_STRING_RECEIVED_OK_ALL" );
   }
   if( (waitStrListResultState == UART_RECEIVE_STRING_ERROR) ){
      debugPrintlnString( "UART_RECEIVE_STRING_ERROR" );
   }
   if( (waitStrListResultState == UART_RECEIVE_STRING_TIMEOUT) ){
      debugPrintlnString( "UART_RECEIVE_STRING_TIMEOUT" );
   }
   
   debugPrintString( "Index of: 'mar': " );
   debugPrintlnInt( expectStringList[0].receiveStrStartIndex );   
   debugPrintString( "Index of: 'pepe': " );
   debugPrintlnInt( expectStringList[1].receiveStrStartIndex );   
   debugPrintString( "Index of: 'hola marola': " );
   debugPrintlnInt( expectStringList[2].receiveStrStartIndex );   
   debugPrintString( "Index of: 'chau': " );
   debugPrintlnInt( expectStringList[3].receiveStrStartIndex );
   
   debugPrintString( "receivedStringResult = " );
   debugPrintlnString( receivedStringResult );
   debugPrintEnter();

   while(1);   
   

   
   
   

   uint8_t rxData = 0;

   char miTexto[] = "OK\r\n";
   char miTexto_Red[] = "+CWJAP:\"miWifi\"\r\n";

   bool_t received = FALSE;

   /* Si presionan TEC1 muestro el mensaje de bienvenida */
/*
   imprimirMensajeDeBienvenida();


   // Analizar respuestas de conexion
   uartWriteString( UART_USB,
      "\r\n\r\nAnalizar respuestas de conexion\r\n\r\n");
   
   uartWriteString( UART_232,
      "AT\r\n");
      
   received = waitForReceiveStringOrTimeoutBlocking(
                UART_232,
                "\r\n",
                sizeof("\r\n"),
                1000
             );

   uartWriteString( UART_232,
      "AT+CWMODE?\r\n");
      
   received = waitForReceiveStringOrTimeoutBlocking(
                UART_232,
                "\r\n",
                sizeof("\r\n"),
                1000
             );

   uartWriteString( UART_232,
      "AT+CWLAP\r\n");
      
   received = waitForReceiveStringOrTimeoutBlocking(
                UART_232,
                "\r\n",
                sizeof("\r\n"),
                1000
             );

   uartWriteString( UART_232,
      "AT+CWJAP?\r\n");
      
   received = waitForReceiveStringOrTimeoutBlocking(
                UART_232,
                "\r\n",
                sizeof("\r\n"),
                1000
             );
             
   // Analizar respuestas de envio de datos
   
   uartWriteString( UART_USB,
      "\r\n\r\nAnalizar respuestas de envio de datos:\r\n\r\n");
   
             
   uartWriteString( UART_232,
      "AT+CIPSTART=\"TCP\",\"api.thingspeak.com\",80\r\n");
      
   received = waitForReceiveStringOrTimeoutBlocking(
                UART_232,
                "\r\n",
                sizeof("\r\n"),
                1000
             );
             
   uartWriteString( UART_232,
      "AT+CIPSEND=39\r\n");
      
   received = waitForReceiveStringOrTimeoutBlocking(
                UART_232,
                "\r\n",
                sizeof("\r\n"),
                1000
             );
             
   uartWriteString( UART_232,
      "GET /update?key=P4JCKHMIPAI5TZ3C&1=99\r\n");
      
   received = waitForReceiveStringOrTimeoutBlocking(
                UART_232,
                "\r\n",
                sizeof("\r\n"),
                1000
             );
   
   
   delay(30000);
*/
   
/*
   uartWriteString( UART_232,
     "AT\r\n");

   received = waitForReceiveStringOrTimeoutBlocking(
                UART_232,
                miTexto,
                sizeof(miTexto),
                1000
             );

   if( received ){
     uartWriteString( UART_USB, "\r\nRecibi OK del ESP\r\n" );
   }
   // Si no lo recibe indica que salio de la funcion
   // waitForReceiveStringOrTimeoutBlocking  por timeout.
   else{
     uartWriteString( UART_USB, "\r\nError de OK\r\n" );
   }

   delay(3000);

   uartWriteString( UART_232,
     "AT+CWJAP?\r\n");

   received = waitForReceiveStringOrTimeoutBlocking(
                UART_232,
                "+CWJAP:\"casaEric\"\r\n",
                sizeof("+CWJAP:\"casaEric\"\r\n"),
                1000
             );

   if( received ){
     uartWriteString( UART_USB, "\r\nEsta conectado a la red que corresponde\r\n" );
   }
   // Si no lo recibe indica que salio de la funcion
   // waitForReceiveStringOrTimeoutBlocking  por timeout.
   else{
     uartWriteString( UART_USB, "\r\nError de conexion de red\r\n" );
   }

   delay(3000);
*/

   /* ------------- REPETIR POR SIEMPRE ------------- */
   while(1) {

      /* Si presionan TEC1 muestro el mensaje de bienvenida */
      if( !gpioRead( TEC1 ) ){
         gpioWrite( LEDB, ON );
         imprimirMensajeDeBienvenida();
         gpioWrite( LEDB, OFF );
      }
      
      /* Si presionan TEC2 muestro el mensaje de bienvenida */
      if( !gpioRead( TEC2 ) ){
         gpioWrite( LED1, ON );
         delay(500);
         uartWriteString( UART_USB, ">> Send: AT\r\n" );
         uartWriteString( UART_232, "AT\r\n" );
         gpioWrite( LED1, OFF );
         
         received = waitForReceiveStringOrTimeoutBlocking( UART_232,
                       "OK\r\n", sizeof("OK\r\n"), 1000 );
         if( received ){
            uartWriteString( UART_USB, "Recibio OK\r\n" );
         }
         
      }
      
      // Bridge entre UART_USB y UART_232

      // Si recibe un byte de la UART_USB lo guardarlo en la variable rxData.
      if( uartReadByte( UART_USB, &rxData ) ){
         // Se reenvía el dato a la UART_232
         uartWriteByte( UART_232, rxData );
      }

      // Si recibe un byte de la UART_232 lo guardarlo en la variable rxData. 
      if( uartReadByte( UART_232, &rxData ) ){
         // Se reenvía el dato a la UART_USB
         uartWriteByte( UART_USB, rxData );
      }
      
   }

   /* NO DEBE LLEGAR NUNCA AQUI, debido a que a este programa no es llamado
      por ningun S.O. */
   return 0 ;
}

/*==================[end of file]============================================*/



Webs:

http://www.sase.com.ar/2017/files/2013/09/Programa-del-SASE-2017.pdf

https://drive.google.com/drive/u/0/folders/0B1pg0ZS50GrILWJQVDBFM2drTGs
https://sites.google.com/site/ingiot3co2017t2/


https://www.luisllamas.es/arduino-wifi-esp8266-esp01/
https://github.com/itead/ITEADLIB_Arduino_WeeESP8266
https://www.allaboutcircuits.com/projects/how-to-make-an-interactive-tcp-server-nodemcu-on-the-esp8266/
https://github.com/bportaluri/WiFiEsp/blob/master/src/WiFiEsp.h
https://github.com/ekstrand/ESP8266wifi
http://www.naylampmechatronics.com/blog/21_Tutorial-ESP8266-Parte-I.html
https://docs.micropython.org/en/v1.8/esp8266/esp8266/quickref.html

https://www.arduino.cc/en/Reference/String
https://www.arduino.cc/en/Reference/StringObject
http://www.alciro.org/alciro/Programacion-cpp-Builder_12/funciones-cadenas-caracteres-string.h_448.htm
https://www.tutorialspoint.com/c_standard_library/string_h.htm
http://www.programmingsimplified.com/c/source-code/c-substring


























